<!doctype html>







<html
  class="not-ready lg:text-base"
  style="--bg:#faf8f1"
  lang="en-us"
  dir="ltr"
><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
  
    
    <title>It&#39;s Okay, Nobody Gets It  Either: Zero-Knowledge Proofs-Silly Goose&#39;s Thoughts</title>
  
    
    <meta name="theme-color" />
  
    <meta name="description" content="
Before anything, don&rsquo;t worry if you don&rsquo;t understand anything. As the title suggests this post will provide you with zero knowledge. In fact, one may call them negative-knowledge proofs as they are one of the rare things that will leave you will fewer brain cells than at the beginning.

Ever said &lsquo;On God&rsquo; to someone, hoping they&rsquo;d believe you even without any actual evidence? Well, zero-knowledge proofs are a bit similar. They let you prove that you know something without revealing it." />
    <meta name="author" content=" " /><link rel="preload stylesheet" as="style" href="../../main.min.css" />
  
    
    <link rel="preload" as="image" href="../../theme.svg" />
    
  
    <link rel="preload" as="image" href="../../github.svg" /><link rel="preload" as="image" href="../../linkedin.svg" />
  
    <link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css"
  integrity="sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI"
  crossorigin="anonymous"
/>
<script
  defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js"
  integrity="sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t"
  crossorigin="anonymous"
></script>
<script
  defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js"
  integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05"
  crossorigin="anonymous"
></script><script>
  document.addEventListener('DOMContentLoaded', () =>
    renderMathInElement(document.body, {
      
      
      delimiters: [
        { left: '$$', right: '$$', display: true },
        { left: '$', right: '$', display: false },
      ],
      
      throwOnError: false,
    }),
  );
</script>

  
    
    <link
      rel="icon"
      href="../../favicon.ico"
    />
    <link
      rel="apple-touch-icon"
      href="../../apple-touch-icon.png"
    />
  
    <meta name="generator" content="Hugo 0.145.0">
  </head><body class="text-black duration-200 ease-out dark:text-white"><header
  class="mx-auto flex h-[4.5rem] max-w-(--w) px-8 whitespace-nowrap lg:justify-center"
>
  <div class="relative z-50 flex items-center ltr:mr-auto rtl:ml-auto">
    <a class="-translate-y-[1px] text-2xl font-medium" href="//localhost:1313/">Silly Goose&#39;s Thoughts</a>
    <div
      class="btn-dark text-[0px] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]"
      role="button"
      aria-label="Dark"
    ></div>
  </div>

  <div
    class="btn-menu relative z-50 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden ltr:-mr-8 rtl:-ml-8"
    role="button"
    aria-label="Menu"
  ></div>

  <script>
    
    const htmlClass = document.documentElement.classList;
    setTimeout(() => {
      htmlClass.remove('not-ready');
    }, 10);

    
    const btnMenu = document.querySelector('.btn-menu');
    btnMenu.addEventListener('click', () => {
      htmlClass.toggle('open');
    });

    
    const metaTheme = document.querySelector('meta[name="theme-color"]');
    const lightBg = '#faf8f1'.replace(/"/g, '');
    const setDark = (isDark) => {
      metaTheme.setAttribute('content', isDark ? '#000' : lightBg);
      htmlClass[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark);
    };

    
    const darkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    if (htmlClass.contains('dark')) {
      setDark(true);
    } else {
      const darkVal = localStorage.getItem('dark');
      setDark(darkVal ? darkVal === 'true' : darkScheme.matches);
    }

    
    darkScheme.addEventListener('change', (event) => {
      setDark(event.matches);
    });

    
    const btnDark = document.querySelector('.btn-dark');
    btnDark.addEventListener('click', () => {
      setDark(localStorage.getItem('dark') !== 'true');
    });
  </script>

  <div
    class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full flex-col justify-center pb-16 duration-200 select-none lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none dark:bg-black"
  ><nav
      class="mt-12 flex justify-center space-x-10 lg:mt-0 lg:items-center ltr:lg:ml-14 rtl:space-x-reverse rtl:lg:mr-14 dark:invert"
    >
      <a
        class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./github.svg)"
        href="https://github.com/gaspardthrl"
        target="_blank"
        rel="me"
      >github</a>
      <a
        class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./linkedin.svg)"
        href="https://linkedin.com/in/gaspard-thoral-49538a230/"
        target="_blank"
        rel="me"
      >linkedin</a>
    </nav>
  </div>
</header><main
      class="prose prose-neutral dark:prose-invert relative mx-auto min-h-[calc(100vh-9rem)] max-w-(--w) px-8 pt-14 pb-16"
    ><article>
  <header class="mb-14">
    <h1 class="!my-0 pb-2.5">It&#39;s Okay, Nobody Gets It  Either: Zero-Knowledge Proofs</h1><div class="text-xs antialiased opacity-60"></div></header>

  <section><div style="text-align: justify">
<p>Before anything, don&rsquo;t worry if you don&rsquo;t understand anything. As the title suggests this post will provide you with <strong>zero knowledge</strong>. In fact, one may call them <strong>negative-knowledge proofs</strong> as they are one of the rare things that will leave you will <em>fewer brain cells</em> than at the beginning.</p>
<hr>
<p>Ever said <em>&lsquo;On God&rsquo;</em> to someone, hoping they&rsquo;d believe you even without any actual evidence? Well, zero-knowledge proofs are a bit similar. They let you prove that you know something <strong>without revealing it</strong>.</p>
<p>This topic is fairly complex. Before diving into what zero-knowledge proofs are, let&rsquo;s make sure that our foundations are rock solid.</p>
<h1 id="wait-a-minute-what-is-a-proof">Wait a minute&hellip; what is a proof?</h1>
<p>A proof is a <strong>logical argument</strong> that <strong>demonstrates the truth of a statement</strong>. For example, what proves that I am French ? Most would say that it is my pretty face coupled with my love for bread, wine, and cheese. While I can&rsquo;t disagree, the strongest proof that I am French is my parentage. Indeed, In France, we have what is called <em>jus sanguinis</em> (blood right), meaning that if one of your parents is French you are automatically granted the French nationality. My parents being both French and the <em>blood right</em> being in effect, I am French.</p>
<p>To <strong>formally describe</strong> proofs, especially in computational complexity and cryptography, we break them down into four key components:</p>
<ul>
<li>
<p><strong>Language</strong> $(\mathcal{L})$ - It consists of <em>all valid inputs</em> that satisfy a given property.</p>
<p><em>Example</em>: Consider the set of all composite numbers (i.e., not prime). The language here is</p>
$$\mathcal{L} = \{x | x \text{ is not a prime number}\}$$</li>
<li>
<p><strong>Verifier</strong> $(\mathcal{V})$ - A function (which can be thought of as an <em>algorithm</em>) that checks whether a given statement belongs to the language. It takes an <em>input</em> and a <em>proof</em> and determines whether the proof is valid.</p>
<p><em>Example</em>: A verifier for composite numbers might check whether a given number has any divisors other than $1$ and itself.</p>
</li>
<li>
<p><strong>Witness</strong> $(w)$ - A piece of evidence that helps convince the verifier that the statement is true. It is sometimes referred to as the <strong>certificate</strong> $(c)$.</p>
<p><em>Example</em>: If someone claims that $91$ is not prime, a witness could be a divisor like $7$ (since $91 = 7 \times 13$)</p>
</li>
<li>
<p><strong>Prover</strong> $(\mathcal{P})$ - The entity that constructs and presents a proof to convince the verifier</p>
<p><em>Example</em>: The prover knows $w = 7$ and want to convince the verifier that $91$ belongs to $\mathcal{L}$ (i.e. that $91$ is <em>composite</em>).</p>
</li>
</ul>
<p>Note that we will only consider <a href="https://en.wikipedia.org/wiki/NP-completeness">NP-Complete</a> problems here. I won&rsquo;t elaborate on them, but just think of them as all problems for which a solution is <strong>easy to verify</strong> but <strong>hard to find</strong> (e.g., a <em>sudoku</em>). If you&rsquo;re interested, <a href="https://www.claymath.org/millennium/p-vs-np/">here</a>&rsquo;s an easy way to make some <em>pocket money</em>.</p>
<img src="../../zero_knowledge_proofs/p_equals_np_meme.png" style="display: block; margin: auto;" />
<hr>
<h1 id="what-does-it-mean-for-a-proof-to-be-zero-knowledge">What does it mean for a proof to be <em>zero-knowledge</em>?</h1>
<p><em>We refer to people following the protocol properly as honest</em>.</p>
<p>For the proof a given statement to be <em>zero-knowledge</em> it must satisfy <strong>three properties</strong>:</p>
<ul>
<li>
<p><strong>Completeness</strong> - If a statement is <strong>true</strong>, then an <em>honest verifier</em> will be convinced of this fact by an <em>honest prover</em> .</p>
<p>In other words, if what you claim to be true is true, the verifier will always validate your claim.</p>
</li>
<li>
<p><strong>Soundness</strong> - If the statement is false, then no <em>cheating prover</em> can convince an <em>honest verifier</em> that it is true, <strong>except with some small probability</strong>.</p>
<p>In other words, if what you claim to be true is false, the verifier will almost always reject your claim. While probabilistic, the error probability is so small that we are okay with this not being true exactly 100% of the time.</p>
</li>
<li>
<p><strong>Zero-knowledge</strong> - If the statement is true, then no verifier learns anything other than the fact that the statement is true.</p>
<p>In other words, the verifier knows that I know but does not know what I know.</p>
</li>
</ul>
<img src="../../zero_knowledge_proofs/introduction_meme.png" style="display: block; margin: auto;" />
<p>Zero-knowledge proofs can be subdivided into <strong>two categories</strong>:</p>
<ul>
<li>
<p><strong>Interactive</strong> - This means that the <em>prover</em> and the <em>verifier</em> exchange <strong>multiple</strong> messages.</p>
</li>
<li>
<p><strong>Non-interactive</strong> - This means that the <em>verifier</em> is convinced by a <strong>single</strong> message.</p>
</li>
</ul>
<h1 id="interactive-zero-knowledge-proofs">Interactive zero-knowledge proofs</h1>
<p>We define an <em>interactive proof</em> as follows:</p>
<p>$(\mathcal{P}, \mathcal{V})$ is an interactive proof for $\mathcal{L}$ (our language), if $V$ is $probabilistic-poly(|x|)$ and:</p>
<ul>
<li>$x\in \mathcal{L} \Rightarrow \Pr[(\mathcal{P}, \mathcal{V})(x) = \text{accept}] \ge c$</li>
<li>$x \notin \mathcal{L} \Rightarrow \forall \ \mathcal{P}^* , \ \Pr[(\mathcal{P}^*, \mathcal{V})(x) = \text{accept}] \le s$</li>
</ul>
<p>We will start by picturing what an interactive proof looks like and how can it reveal no information using the <a href="https://en.wikipedia.org/wiki/Zero-knowledge_proof#The_Ali_Baba_cave">Ali Baba Cave</a> example as well as the <a href="https://en.wikipedia.org/wiki/Zero-knowledge_proof#Hamiltonian_cycle_for_a_large_graph">Hamiltonian Cycle</a> example.</p>
<h2 id="ali-baba-and-his-cave">Ali Baba and his cave</h2>
<p>Picture this: You are in front of a cave with a single entrance that branches into two paths, $A$ and $B$. These paths are separated by a <strong>password-protected door</strong>. Without the password, one must <strong>exit the cave using the same path they entered</strong>.</p>
<img src="../../zero_knowledge_proofs/ali_baba_cave_example.png" style="display: block; margin: auto;" />
<br>
<p>You, the <em>prover</em>, claim to know the password. I, the <em>verifier</em>, want to confirm this without you revealing the password to me.</p>
<p>How can I be sure that you indeed know the password without you telling me the password and trying out myself ?</p>
<p>Here&rsquo;s how we can achieve this:</p>
<ul>
<li>You enter the cave without me seeing which path you take.</li>
<li>I then ask you to exit the cave using a <strong>specific path</strong>, say $A$.</li>
</ul>
<p>There are four possible outcomes:</p>
<ul>
<li>You <em>don&rsquo;t know</em> the password but <strong>luckily chose path</strong> $A$ initially.</li>
<li>You <em>don&rsquo;t know</em> the password and chose path $B$, so you exit through $B$.</li>
<li>You <em>know</em> the password and happened to choose path $A$ initially.</li>
<li>You <em>know</em> the password, initially chose $B$, but <strong>can use the password</strong> to exit through $A$.</li>
</ul>
<p>If you exit through $B$ when asked to use $A$, I&rsquo;ll <strong>reject</strong> your claim because you either don&rsquo;t have the password, or you have the password but are <em>too dumb</em> for me to accept you. If you exit through $A$, I won&rsquo;t immediately accept your claim, as <strong>you might have been lucky</strong>.</p>
<p>If we perform this experience only once, and you happen to exit the cave taking path $A$, there is a $50$ percent chance that you don&rsquo;t have the password and were just lucky.</p>
<p>That&rsquo;s where the <strong>iterative</strong> aspect of these proofs comes into play: Each time we replay this cave adventure, with me randomly picking your exit path, your odds of consistently lucking out plummet. It&rsquo;s like trying to win a coin toss not just once, but over and over again.</p>
$$
\lim_{n \to \infty}{\frac{1}{2^n}} = 0
$$<p>Obviously we don&rsquo;t repeat this experience an infinite amount of time but we do so <strong>until this probability becomes too small for us to care</strong>.</p>
<p>Now what about a more math-focused example ?</p>
<h2 id="hamiltonian-cycle-for-a-graph">Hamiltonian cycle for a graph</h2>
<p>Let there be a <em>graph</em> $G$ which is very large.</p>
<p>You, the <em>prover</em>, claim to know a <strong>Hamiltonian cycle</strong> (that is, a path that visits each vertex exactly once) for $G$. I, the <em>verifier</em>, want to confirm this without you revealing this cycle to me.</p>
<img src="../../zero_knowledge_proofs/hamiltonian_cycle_example.png" style="display: block; margin: auto;" />
<p>To achieve this, we will modify our previous <em>cave adventure</em> and do the following for <strong>each round</strong>:</p>
<ul>
<li>
<p>You create a graph $H_i$ which is <strong>isomorphic</strong> to $G$ (that is, the same graph as $G$ except the vertices have different names).</p>
<p>$\Rightarrow$ It&rsquo;s easy to translate a Hamiltonian cycle between isomorphic graphs and thus you also know a Hamiltonian cycle for $H_i$.</p>
</li>
<li>
<p>You <strong>commit</strong> $H_i$ such that you cannot modify it afterward.</p>
</li>
<li>
<p>I then ask you to show either the <strong>isomorphism</strong> between $H_i$ and $G$ or a <strong>Hamiltonian cycle</strong> in $H_i$.</p>
</li>
</ul>
<p>If you do know a Hamiltonian cycle in $G$, then it is pretty easy for you to submit a graph $H_i$ that is <strong>isomorphic</strong> to $G$ and for which you know a Hamiltonian cycle.</p>
<p>On the other hand, if you don&rsquo;t know any Hamiltonian cycle in $G$, you have to take a guess on which question I am going to ask:</p>
<ul>
<li>If you think that I will ask you to show the <em>isomorphism</em> between $H_i$ and $G$, you simply need to submit a graph $H_i$ <em>isomorph</em> to $G$.</li>
<li>If you think that I will ask you to show a <em>Hamiltonian cycle</em> in $H_i$, you simply need to submit a graph $H_i$ for which you know a Hamiltonian cycle.</li>
</ul>
<p>There is basically no way for you to correctly answer my question if your prediction is incorrect.</p>
<p>Once again, you might be lucky at first but as the number of iterations increases, the probability that you do not know a Hamiltonian cycle in $G$ becomes negligible.</p>
<p>Note that $H_i$ is different <strong>for each iteration</strong>. If it was not, I could deduct the Hamiltonian cycle in $G$ in only two iterations by first asking you about a Hamiltonian cycle in $H_i$, and then asking about an isomorphism between this same $H_i$ and $G$.</p>
<hr>
<p>So what ? We showed for two different problems that we could provide a proof that did not reveal information. I can already picture you saying that the approaches were totally different and that it might be <strong>difficult to do the same thing for every problem</strong>.
Well, you would be right to question this approach as it is <strong>hard to generalize</strong>. However, let me introduce you to a very cool concept from theory of computation: <strong>reductions</strong>.</p>
<p>This concept is a bit tricky and I won&rsquo;t go into details but <strong>BASICALLY</strong>, it means that a problem $A$ can be converted to a problem $B$ if $B$ is at least as hard as $A$.</p>
<img src="../../zero_knowledge_proofs/reduction_spider_man_meme.png" style="display: block; margin: auto;" />
<p>Furthermore, we have one category of problems that are referred to as &ldquo;satisfiability problems&rdquo; which ask if a problem has a solution. Satisfiability problems are actually very hard and that&rsquo;s great because it is relatively easy to go from a problem $A$ to one of these problems (you <del>just</del> need to formulate your problem correctly).</p>
<p>Take a step back, take a deep breath, and think about it: That&rsquo;s amazing because now, we only need to develop one (or just a few) algorithm that let us prove a solution to a satisfiability problem without revealing it.</p>
<p>Think of it this way: You know how to go from Rome to somewhere in the desert. The following great theorem &ldquo;All roads lead to Rome&rdquo; tells you that to go from anywhere in the world to this point in the desert you don&rsquo;t need to find a new route. You just need to go to Rome and then go to the point in the desert.</p>
<p>What about achieving the same result as before but without interactions ? Well, it&rsquo;s possible and we call this <strong>Zero-Knowledge Succinct Non-Interactive Argument of Knowledge</strong> a.k.a. <strong>zk-SNARK</strong>.</p>
</section>

  <div class="mt-24" id="graphcomment"></div>
  <script type="text/javascript">
    var __semio__params = {
      graphcommentId: 'YOUR_GRAPH_COMMENT_ID',
      behaviour: {
        
      },
      
    };

    function __semio__onload() {
      __semio__gc_graphlogin(__semio__params);
    }

    (function () {
      var gc = document.createElement('script');
      gc.type = 'text/javascript';
      gc.async = true;
      gc.onload = __semio__onload;
      gc.defer = true;
      gc.src =
        'https://integration.graphcomment.com/gc_graphlogin.js?' + Date.now();
      (
        document.getElementsByTagName('head')[0] ||
        document.getElementsByTagName('body')[0]
      ).appendChild(gc);
    })();
  </script></article></main><footer
  class="mx-auto flex h-[4.5rem] max-w-(--w) items-center px-8 text-xs tracking-wider uppercase opacity-60"
>
  <div class="mr-auto">&copy;2025<a class="link" href="../../">Silly Goose&#39;s Thoughts</a></div>
</footer>
</body>
</html>
